import { beforeEach, describe, expect, it, vi } from 'vitest'

import { JwtTokenGeneratorService } from '../../../../src/adapters/secondary/services/jwt-token-generator.service.js'
import { JwtUtil } from '../../../../src/infrastructure/security/jwt.util.js'
import type { JwtUserClaims } from '../../../../src/shared/types/index.js'

// Mock JwtUtil
vi.mock('../../../../src/infrastructure/security/jwt.util.js', () => ({
  JwtUtil: {
    generateToken: vi.fn(),
  },
}))

describe('JwtTokenGeneratorService', () => {
  let service: JwtTokenGeneratorService

  beforeEach(() => {
    vi.clearAllMocks()
    service = new JwtTokenGeneratorService()
  })

  describe('constructor', () => {
    it('should create an instance of JwtTokenGeneratorService', () => {
      expect(service).toBeInstanceOf(JwtTokenGeneratorService)
    })

    it('should implement TokenGeneratorPort interface', () => {
      expect(service).toHaveProperty('generateToken')
      expect(typeof service.generateToken).toBe('function')
    })
  })

  describe('generateToken', () => {
    describe('successful token generation', () => {
      it('should generate a token with valid user claims', () => {
        const claims: JwtUserClaims = {
          sub: 'user-123',
          email: 'test@example.com',
          roles: ['user'],
        }
        const expectedToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.mock.token'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(expectedToken)

        const result = service.generateToken(claims)

        expect(result).toBe(expectedToken)
        expect(JwtUtil.generateToken).toHaveBeenCalledTimes(1)
        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })

      it('should delegate to JwtUtil.generateToken', () => {
        const claims: JwtUserClaims = {
          sub: 'user-456',
          email: 'another@example.com',
          roles: ['admin'],
        }
        const mockToken = 'mock.jwt.token.string'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        service.generateToken(claims)

        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })

      it('should return the token generated by JwtUtil', () => {
        const claims: JwtUserClaims = {
          sub: 'user-789',
          email: 'user@example.com',
          roles: ['user', 'moderator'],
        }
        const expectedToken = 'expected.token.value'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(expectedToken)

        const result = service.generateToken(claims)

        expect(result).toBe(expectedToken)
      })
    })

    describe('handling different user claims', () => {
      it('should handle user with single role', () => {
        const claims: JwtUserClaims = {
          sub: 'user-single-role',
          email: 'single@example.com',
          roles: ['user'],
        }
        const mockToken = 'token.for.single.role'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = service.generateToken(claims)

        expect(result).toBe(mockToken)
        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })

      it('should handle user with multiple roles', () => {
        const claims: JwtUserClaims = {
          sub: 'user-multi-role',
          email: 'multi@example.com',
          roles: ['user', 'admin', 'superadmin'],
        }
        const mockToken = 'token.for.multiple.roles'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = service.generateToken(claims)

        expect(result).toBe(mockToken)
        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })

      it('should handle user with empty roles array', () => {
        const claims: JwtUserClaims = {
          sub: 'user-no-roles',
          email: 'noroles@example.com',
          roles: [],
        }
        const mockToken = 'token.without.roles'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = service.generateToken(claims)

        expect(result).toBe(mockToken)
        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })

      it('should handle user with UUID format subject', () => {
        const claims: JwtUserClaims = {
          sub: '550e8400-e29b-41d4-a716-446655440000',
          email: 'uuid@example.com',
          roles: ['user'],
        }
        const mockToken = 'token.with.uuid'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = service.generateToken(claims)

        expect(result).toBe(mockToken)
        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })

      it('should handle user with special characters in email', () => {
        const claims: JwtUserClaims = {
          sub: 'user-special',
          email: 'user+test@sub.domain.example.com',
          roles: ['user'],
        }
        const mockToken = 'token.with.special.email'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = service.generateToken(claims)

        expect(result).toBe(mockToken)
        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })
    })

    describe('token format validation', () => {
      it('should return a string value', () => {
        const claims: JwtUserClaims = {
          sub: 'user-123',
          email: 'test@example.com',
          roles: ['user'],
        }
        const mockToken = 'string.token.value'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = service.generateToken(claims)

        expect(typeof result).toBe('string')
      })

      it('should return non-empty string', () => {
        const claims: JwtUserClaims = {
          sub: 'user-456',
          email: 'nonempty@example.com',
          roles: ['user'],
        }
        const mockToken = 'non.empty.token'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = service.generateToken(claims)

        expect(result).toBeTruthy()
        expect(result.length).toBeGreaterThan(0)
      })

      it('should handle realistic JWT token format', () => {
        const claims: JwtUserClaims = {
          sub: 'user-789',
          email: 'realistic@example.com',
          roles: ['admin'],
        }
        const realisticToken =
          'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyLTc4OSIsImVtYWlsIjoicmVhbGlzdGljQGV4YW1wbGUuY29tIiwicm9sZXMiOlsiYWRtaW4iXSwiaWF0IjoxNjczMDAwMDAwfQ.signature'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(realisticToken)

        const result = service.generateToken(claims)

        expect(result).toBe(realisticToken)
        expect(result).toMatch(/^[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+$/)
      })
    })

    describe('adapter pattern validation', () => {
      it('should act as a proper adapter to JwtUtil', () => {
        const claims: JwtUserClaims = {
          sub: 'adapter-test',
          email: 'adapter@example.com',
          roles: ['user'],
        }
        const mockToken = 'adapter.pattern.token'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        service.generateToken(claims)

        // Verify the adapter delegates exactly once
        expect(JwtUtil.generateToken).toHaveBeenCalledTimes(1)
        // Verify the adapter passes claims without modification
        expect(JwtUtil.generateToken).toHaveBeenCalledWith(claims)
      })

      it('should not modify claims before passing to JwtUtil', () => {
        const claims: JwtUserClaims = {
          sub: 'immutable-test',
          email: 'immutable@example.com',
          roles: ['user', 'admin'],
        }
        const claimsCopy = { ...claims, roles: claims.roles ? [...claims.roles] : [] }
        const mockToken = 'immutable.claims.token'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        service.generateToken(claims)

        // Verify claims passed to JwtUtil match original claims
        const callArgs = vi.mocked(JwtUtil.generateToken).mock.calls[0]?.[0]
        expect(callArgs).toEqual(claimsCopy)
      })

      it('should forward return value from JwtUtil without modification', () => {
        const claims: JwtUserClaims = {
          sub: 'forward-test',
          email: 'forward@example.com',
          roles: ['user'],
        }
        const exactToken = 'exact.unmodified.token.value'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(exactToken)

        const result = service.generateToken(claims)

        expect(result).toBe(exactToken)
        expect(result).toStrictEqual(exactToken)
      })
    })

    describe('multiple invocations', () => {
      it('should generate different tokens for different users', () => {
        const claims1: JwtUserClaims = {
          sub: 'user-1',
          email: 'user1@example.com',
          roles: ['user'],
        }
        const claims2: JwtUserClaims = {
          sub: 'user-2',
          email: 'user2@example.com',
          roles: ['admin'],
        }

        vi.mocked(JwtUtil.generateToken)
          .mockReturnValueOnce('token.for.user1')
          .mockReturnValueOnce('token.for.user2')

        const result1 = service.generateToken(claims1)
        const result2 = service.generateToken(claims2)

        expect(result1).toBe('token.for.user1')
        expect(result2).toBe('token.for.user2')
        expect(JwtUtil.generateToken).toHaveBeenCalledTimes(2)
      })

      it('should handle consecutive calls independently', () => {
        const claims: JwtUserClaims = {
          sub: 'consecutive-user',
          email: 'consecutive@example.com',
          roles: ['user'],
        }

        vi.mocked(JwtUtil.generateToken)
          .mockReturnValueOnce('first.token')
          .mockReturnValueOnce('second.token')
          .mockReturnValueOnce('third.token')

        const token1 = service.generateToken(claims)
        const token2 = service.generateToken(claims)
        const token3 = service.generateToken(claims)

        expect(token1).toBe('first.token')
        expect(token2).toBe('second.token')
        expect(token3).toBe('third.token')
        expect(JwtUtil.generateToken).toHaveBeenCalledTimes(3)
      })

      it('should maintain stateless behavior across invocations', () => {
        const claims1: JwtUserClaims = {
          sub: 'stateless-1',
          email: 'stateless1@example.com',
          roles: ['user'],
        }
        const claims2: JwtUserClaims = {
          sub: 'stateless-2',
          email: 'stateless2@example.com',
          roles: ['admin'],
        }

        vi.mocked(JwtUtil.generateToken).mockReturnValue('mock.token')

        service.generateToken(claims1)
        service.generateToken(claims2)

        // Verify each call is independent
        const calls = vi.mocked(JwtUtil.generateToken).mock.calls
        expect(calls[0]?.[0]).toEqual(claims1)
        expect(calls[1]?.[0]).toEqual(claims2)
        expect(calls.length).toBe(2)
      })
    })

    describe('integration with port interface', () => {
      it('should satisfy TokenGeneratorPort contract', () => {
        const claims: JwtUserClaims = {
          sub: 'port-test',
          email: 'port@example.com',
          roles: ['user'],
        }
        const mockToken = 'port.interface.token'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        // Should accept JwtUserClaims and return string
        const result: string = service.generateToken(claims)

        expect(typeof result).toBe('string')
        expect(result).toBe(mockToken)
      })

      it('should work with dependency injection', () => {
        // Create a new instance to simulate DI container behavior
        const injectedService = new JwtTokenGeneratorService()
        const claims: JwtUserClaims = {
          sub: 'di-test',
          email: 'di@example.com',
          roles: ['user'],
        }
        const mockToken = 'di.container.token'

        vi.mocked(JwtUtil.generateToken).mockReturnValue(mockToken)

        const result = injectedService.generateToken(claims)

        expect(result).toBe(mockToken)
        expect(injectedService).toBeInstanceOf(JwtTokenGeneratorService)
      })
    })
  })
})
